1.  **Leading Question**: Route calculation based on location inputs

> The project will find the best route based on user requirements (best
> time, most transfer, highest passenger count etc) and the departure
> and destination coordinations, we would search the best routes by air
> travel to the user’s preferences. We would like to give the results in
> both lists of possible matches of routes or on a map visually. Similar
> to a search engine of searching for the best air travel route on user
> preferences.

2.  **Dataset Acquisition and Processing**: OpenFlights.org

> We will use at least one publicly accessible dataset; more
> specifically, a dataset from OpenFlights.org. Particularly the
> routes.dat, which contains most information needed, such as arrival
> and departure airports, flight number, and airline. This will be used
> as our main filter, with supplementing data as airports.dat,
> countries.dat, and airlines.dat to help the data processing. The
> program will use the said three data to provide filtering options and
> find selections from routes.dat.
>
> Most of the data set we are working with are already filtered and
> sorted, we expect minimal errors as long as we account for any
> possible (N/A) or invalid data entries. Under conditions with missing
> data (such as no departure location) we will consider datas outdated
> and would not use it. Still, as a precaution we will test for
> edge-based and input errors.

3.  **Graph Algorithms**  
    > We will use Djiksha’s Algorithm to determine the best flight to
    > take between different cities, factoring in distance, timing, and
    > perhaps even ticket price as the different forms of “cost.” At the
    > end, we will return a list of the best recommended flights and
    > their details. Dijkstra's shortest path algorithm is O(ElogV)
    > where V = total vertices/cities and E = total edges/flights  
    >   
    > We will also use another algorithm to tackle a form of the
    > traveling salesman problem! It will be similar to Dijiksha’s
    > algorithm with nearly identical cost calculations. Except this
    > time, the algorithm will look for the best path linking multiple
    > destinations. An additional “cost” factor is also included: the
    > time available between flights (with a couple hours being good, a
    > day being unideal, and anything less than half an hour being
    > impossible). At the end, the program returns a list of the best
    > choices. brute forcing this problem for n destinations gives an
    > expected complexity of n!, but our algorithm should improve
    > runtime drastically.

> For traversal we will use the Depth first search, by pinning airports
> as nodes and routes between them as edges. We will start from
> departure and destination airports and traverse through the graph
> edges (in this case the routes) to find the optimal routes based on
> the user’s inputs. This will also be used when we visually show the
> routes on the map.

4.  **Timeline**

> Throughout the project we will complete multiple checkpoints
>
> 04/09 - project proposal submission
>
> 04/10 - set up our repo
>
> 04/17 - data acquisition: downloading relevant and required data from
> reliable sources.
>
> 04/17 - data processing: understanding the format of acquired data and
> properly extracting what we need within program
>
> completion of each individual algorithm,
>
> 04/19 - Mid Project Presentation
>
> 04/22 - Write and implement graph from data sets
>
> 04/25 - Write and implement DFS
>
> 04/30 - Write and implement Djiksha’s Algorithm
>
> 05/06 - Write and implement traveling salesman problem
>
> 05/10 - Production of final deliverables: presentation of our
> information
>
> debugging - creating test cases and extensive testing.
>
> 05/12 - submission
>
> \[pending date\] - last MP finished, increase work time on the project
>
> \[pending date\] - last exam finished, increase work time on the
> project

Signed:

Kelvin Chen, kelvin3

Ariocie Liang, arliang2
