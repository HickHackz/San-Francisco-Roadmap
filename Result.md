# Result

1. **Graph Structure** The graph constructed through reading datas in of SF.cedge and SF.cnode into 7 vectors of integers labeled nodeID, xLocs, yLocs, edgeIDs, edgeLength, startNode, and endNode. nodeID, xLocs, yLocs store informations about nodes and edgeIDs, edgeLength, startNode, endNode store information about the edges. A 2D vector called adjacencyList is created and has nodeID.size() number of empty vectors pushed into it. An iteration is performed on edgeIDs, startNode,and endNode so that the id of an edge is pushed onto adjacencyList[ startNode[ id ] ] and adjacencyList[ endNode[ id ] ], turning adjacencyList into an adjacency list for all the edges in the graph. This adjacency list is used to create the incidentEdges function that return all incident edges of a node, the getAdjacentNodes function that get all nodes adjacent to a node, and areAdjecent function that check if two nodes are adjacent to each other. No special discovery was made for this part of the project.

2. **DFS Traversal Through Iterator** Our DFS iterator contain two constructors, the ++, * and != operations. A DFS iterator is created with the id of a starting node and pointer to a graph. Its constructor establish the needed arrays and variables needed to keep track of visited node and edges, the current node, and the map of discovery and back edges.It keep a Everytime operator++ is called, if the current stack is not empty, a pop is performed on the stack. Then all the edges adjecent to the current is found using the incidentEdges function of the graph. For each incident edges, the node connected to the current is identified; if the node was not previously visited, it is now considered visited and pushed onto the stack; the edge is considered a discovery edge and pushed into the respective vector. Otherwise the edge is considered a back edge and pushed into the respective vector. After the iterator went through every node of the graph, a map of discovery and back edges can be found in discoveryEdges and backEdges. The != operator simply check if the iterator reach the end of the graph. When working on the DFS iterator, I discovered that my implemetation of DFS traversal is different than the one presented in the lecture. Instead of an recursive approach, I ensure the depth first aspect of the traversal through using a stack. This implemetation does cause changes to the order in which the nodes are visited compare to the functions used in lecture.

3. **Dijikstra's Algorithm** Our Dijikstra's Algorithm is completed under a piority queue implemetation. A structure called Node is created in our dijikstra's algorithm that 
stores the nodeID, the previously visited node, the distance of the path, and wither it has been visited or not. This struct is made for all verticies, and is then implemented using dijkstras by comparing the current path to the path of the neighboring node. The priority queue is used to store the path with the shortest distance, keeping it at the top of the queue. Lastly, once the shortest path is found, the nodeID's of the shortest path are then popped from the queue, and sent to a new vector. With these nodeID's the edges between the nodes of the path are then found and are returned in the form of a vector of integers. We chose to use a priority queue for our implementation as it seemed easy to understand because it automatically keeps the shortest path at the top of the queue. We also decided to use an adjacency list to help with the runtime of finding the adjacent edges of a node, which was needed to run dijkstras. 
4. **Graphical Representation** Our Graphical Representation is completed by exporting a PNG with all the nodes and edges plotted accordingly to their locations from our data files.  The algorithm starts by checking all the x and y coordinates from the data and finds the max coordinates.  These max coordinates are used as the dimensions for the PNG.  The first for loop iterates across the EdgeID vector, which breaks down each edge to it's start and end nodes.  The start and end nodes are then represented as a "sub plot" in the PNG with their own width and heights representing the edges span in the x and y direction.  Two more for loops are used to iterate across the sub plot.  These for loops are designed to take in consideration which direction the end node is relative to the start node, and traverse towards the end node.  The slope between the start node and end node is calculated and compared to the slope between the start node and all the points within the sub plot.  If the two slopes equal each other (or within the variable tolerance, which depends on the length of the edge for more accuracy), then the pixel is colored black.  After all edges have been processed, the function then prints out all the nodes in the graph with a red x.  The function has a bool parameter withSol which when true, will call Dijkstraâ€™s algorithm to generate the edge ids of the shortest path between two points.  These path edges are printed on the PNG in the same manner all the other edges are.
