# Project Proposal

1. **Graph Structure** The graph constructed through reading datas in of SF.cedge and SF.cnode into 7 vectors of integers labeled nodeID, xLocs, yLocs, edgeIDs, edgeLength, startNode, and endNode. nodeID, xLocs, yLocs store informations about nodes and edgeIDs, edgeLength, startNode, endNode store information about the edges. A 2D vector called adjacencyList is created and has nodeID.size() number of empty vectors pushed into it. An iteration is performed on edgeIDs, startNode,and endNode so that the id of an edge is pushed onto adjacencyList[ startNode[ id ] ] and adjacencyList[ endNode[ id ] ], turning adjacencyList into an adjacency list for all the edges in the graph. This adjacency list is used to create the incidentEdges function that return all incident edges of a node, the getAdjacentNodes function that get all nodes adjacent to a node, and areAdjecent function that check if two nodes are adjacent to each other. No special discovery was made for this part of the project.

2. **DFS Traversal Through Iterator** Our DFS iterator contain two constructors, the ++, * and != operations. A DFS iterator is created with the id of a starting node and pointer to a graph. Its constructor establish the needed arrays and variables needed to keep track of visited node and edges, the current node, and the map of discovery and back edges.It keep a Everytime operator++ is called, if the current stack is not empty, a pop is performed on the stack. Then all the edges adjecent to the current is found using the incidentEdges function of the graph. For each incident edges, the node connected to the current is identified; if the node was not previously visited, it is now considered visited and pushed onto the stack; the edge is considered a discovery edge and pushed into the respective vector. Otherwise the edge is considered a back edge and pushed into the respective vector. After the iterator went through every node of the graph, a map of discovery and back edges can be found in discoveryEdges and backEdges. The != operator simply check if the iterator reach the end of the graph. When working on the DFS iterator, I discovered that my implemetation of DFS traversal is different than the one presented in the lecture. Instead of an recursive approach, I ensure the depth first aspect of the traversal through using a stack. This implemetation does cause changes to the order in which the nodes are visited compare to the functions used in lecture.

3. **Dijikstra's Algorithm** Our Dijikstra's Algorithm is completed under a piority queue implemetation. A structure called Node is created in our dijikstra's algorithm that 

4. **Graphical Representation**
 