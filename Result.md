# Result

1. **Graph Structure** The graph constructed through reading datas in of SF.cedge and SF.cnode into 7 vectors of integers labeled nodeID, xLocs, yLocs, edgeIDs, edgeLength, startNode, and endNode. nodeID, xLocs, yLocs store informations about nodes and edgeIDs, edgeLength, startNode, endNode store information about the edges. A 2D vector called adjacencyList is created and has nodeID.size() number of empty vectors pushed into it. An iteration is performed on edgeIDs, startNode,and endNode so that the id of an edge is pushed onto adjacencyList[ startNode[ id ] ] and adjacencyList[ endNode[ id ] ], turning adjacencyList into an adjacency list for all the edges in the graph. This adjacency list is used to create the incidentEdges function that return all incident edges of a node, the getAdjacentNodes function that get all nodes adjacent to a node, and areAdjecent function that check if two nodes are adjacent to each other. No special discovery was made for this part of the project.

2. **DFS Traversal Through Iterator** Our DFS iterator contain two constructors, the ++, * and != operations. A DFS iterator is created with the id of a starting node and pointer to a graph. Its constructor establish the needed arrays and variables needed to keep track of visited node and edges, the current node, and the map of discovery and back edges.It keep a Everytime operator++ is called, if the current stack is not empty, a pop is performed on the stack. Then all the edges adjecent to the current is found using the incidentEdges function of the graph. For each incident edges, the node connected to the current is identified; if the node was not previously visited, it is now considered visited and pushed onto the stack; the edge is considered a discovery edge and pushed into the respective vector. Otherwise the edge is considered a back edge and pushed into the respective vector. After the iterator went through every node of the graph, a map of discovery and back edges can be found in discoveryEdges and backEdges. The != operator simply check if the iterator reach the end of the graph. When working on the DFS iterator, I discovered that my implemetation of DFS traversal is different than the one presented in the lecture. Instead of an recursive approach, I ensure the depth first aspect of the traversal through using a stack. This implemetation does cause changes to the order in which the nodes are visited compare to the functions used in lecture.

3. **Dijikstra's Algorithm** Our Dijikstra's Algorithm is completed under a piority queue implemetation. A structure called Node is created in our dijikstra's algorithm that 
stores the nodeID, the previously visited node, the distance of the path, and wither it has been visited or not. This struct is made for all verticies, and is then implemented using dijkstras by comparing the current path to the path of the neighboring node. The priority queue is used to store the path with the shortest distance, keeping it at the top of the queue. Lastly, once the shortest path is found, the nodeID's of the shortest path are then popped from the queue, and sent to a new vector. With these nodeID's the edges between the nodes of the path are then found and are returned in the form of a vector of integers. We chose to use a priority queue for our implementation as it seemed easy to understand because it automatically keeps the shortest path at the top of the queue. We also decided to use an adjacency list to help with the runtime of finding the adjacent edges of a node, which was needed to run dijkstras. 
4. **Graphical Representation**
 
